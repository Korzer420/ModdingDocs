---
nav_order: 8
---
# Hooks
Hooks (more formally known as events) are the main way to interact with Hollow Knight's code. We can use them to wait for an event to happen in game, then intercept data related to that event and trigger some code and potentially return different data to what we received.   
<br>There are 3 major type of hooks in the Modding API each of which will be explained below.

## ModHooks
ModHooks are hooks that are built into the Modding API that allow us to interact will Hollow Knight code.
To use a Modhook, you need to subscribe to the hook. For example:
```cs
public class MyFirstMod:Mod
{
    // The method that will be called by Modding API when the game first opens
    public override void Initialize()
    {
        // We subscribe to HeroUpdateHook which is an hook that is triggered when the 'Update' Function is called for the player (once every frame)
        ModHooks.HeroUpdateHook += OnHeroUpdate;
    }
    
    //This event's method doesn't take any Parameters. normally the IDE can generate this function for you with the correct parameters
    public void OnHeroUpdate()
    {
       //code to run
    }
}
```
> Note: Your IDE (Visual Studio Community/Jetbrains Rider) can generate this function for you with the correct parameters. To do this, [see example video](https://youtu.be/oH-lbfZORw0) or type in `ModHooks.HeroUpdateHook += OnHeroUpdate;`, Then right click on the now red highlighted `OnHeroUpdate` and click on the light bulb icon (called 'Quick actions and Refactoring') and choose 'Generate Method'.

There are many modhooks available to be used.  
- Explanations for most common hooks can be found in [ModHook Reference](Hooks/modhooks.md)
- A list of all hooks can be found in the [API Documentation](https://hk-modding.github.io/api/api/Modding.ModHooks.html#events)
## On Hooks
On Hooks are a type of hooks that are generated by MonoMod HookGen. This allows you to hook onto and replace any method in the games code.
Any function (private or public) that the game's code has can be onHooked which makes the combination of Modhooks and OnHooks very useful while creating a mod.
OnHooks allow you to do 2 main things
1. Insert code before/after a method is run.
2. Replace the games method with your code.  

To subscribe to OnHook you'd first need to find a method. In this example we will be using `HeroController.AddGeo(int amount)` to demonstrate. 
So to OnHook `HeroController.AddGeo` we would do:
```cs
//We subscribe to the hook
On.HeroController.AddGeo += OnHCAddGeo;

   
private void OnHCAddGeo(On.HeroController.orig_AddGeo orig, HeroController self, int amount)
{
    //code before original method is called
    if (amount < 100)
    {
        //if amount of geo to be added is less than 100, return (and dont call original method)
        return;
    }
    
    orig(self, amount); // call original method
    
    //code after method is called
    Log($"the amount of total geo is {self.geoCounter.playerData.geo}"
}
```

From the above example, the function generated contains an odd looking argument `On.HeroController.orig_AddGeo` called `orig`. This is a delegate that will allow us to call the original function if we wish.  
The second argument `HeroController self` is the object that the method is being called on. Since this method is not static, it is called on an instance of the class (in this case HeroController) which is then passed as an argument for us to use.
Note that this argument will not be present for static methods.  
The third argument `int amount` is the normal argument the function takes.

To call the original method we would do: `orig(self, amount)`. We call orig and pass in self and the rest of the arguments of the function (in this case `int amount`).
In the case the function has no other arguments we would just do `orig(self)`. If the function had more arguments, we would pass those in too after self.

While using OnHooks we need to be careful of a few things
1. If your goal is to insert code before/after a method has run, don't forget to call `orig(self)` or it might cause some unexpected behaviour especially for important functions like HeroController.Start and PlayerMakerFSM.Awake.
2. Unless necessary for the mod, dont replace the method with your own because if `orig(self)` is not called, other mods that also OnHooked this method will not be able to run their code. 
This is because the second mod's onHook will only be called when the first mod's onHook calls `orig(self)` (i.e. if first mod never calls `orig(self)` second mod's hook wont be called). 
If the vanilla game code is conflicting with your mod then by all means do replace the method but just make sure to keep this in mind.
3. If you want to replace a method, make sure to not call `orig(self)`. Also if you do this it is very likely you will encounter private fields and methods that you would like to access. 
To be able to do this, [Reflection](reflection.md) is the best way to do it.

For more information about OnHooks please refer to the [OnHooks Page](Hooks/onhooks.md)
> Note: Your IDE (Visual Studio Community/Jetbrains Rider) can generate this function for you with the correct parameters.  To do this, [see example video](https://youtu.be/oH-lbfZORw0) or type in `On.HeroController.AddGeo += OnHCAddGeo;`, Then right click on the now red highlighted `OnHCAwake` and click on the light bulb icon (called 'Quick actions and Refactoring') and choose 'Generate Method'.

> Note: To be able to write OnHooks, you will need to import `MMHOOK_Assembly-CSharp.dll` and `MMHOOK_PlayMaker.dll` from your managed folder.
## IL Hooks
While ModHooks allow you to intercept at certain points to modify some values and On Hooks allow you to modify what happens before and after a method is called, sometimes you'll need to modify existing code. That's what IL Hooks are for.

IL (Intermediate language) is a programming language that functions as a "bridge" between our normal readable code and the code, that the machine can actually read and execute. Compiling a program will "translate" the code in IL and then, when needed in machine code.

To make using this a bit more clearly we will look at an example. We'll try to modify the SetDarkness Methods, which checks at the start of the room if the player has the lantern. First we look at the original function:
```cs
public void SetDarkness(int darkness)
{
	if (darkness > 0 && this.playerData.GetBool("hasLantern"))
	{
		this.wieldingLantern = true;
		return;
	}
	this.wieldingLantern = false;
}
```
This method persist out of many instructions that the machine must execute. In dnSpy or IlSpy we can exactly see which il instructions will be taken:
![IL_Example](https://user-images.githubusercontent.com/79503617/178123075-4231f65c-f791-47f6-b532-d734682e08c1.PNG)
In the third column you can the operation code for the instructions. Here's a full list off the instructions: https://en.wikipedia.org/wiki/List_of_CIL_instructions
This is all we needed to get started. First we create the hook for the method:
```cs
IL.HeroController.SetDarkness += MyILHook;
```
Now we will create the EventHandler:
```cs
private void MyILHook(MonoMod.Cil.ILContext il)
{
    ILCursor cursor = new ILCursor(il).Goto(0); // We need a cursor to navigate through the instructions (we do Goto() to jump to the first, just in case.);
}
```
With this setup we want to find the instructions that we want to modify. We need to move the cursor to the instruction that is interesting for us. we use cursor.TryGotoNext() for that. This method return false if no matches was found:
```cs
private void MyILHook(MonoMod.Cil.ILContext il)
{
    ILCursor cursor = new ILCursor(il).Goto(0); // We need a cursor to navigate through the instructions (we do Goto() to jump to the first, just in case.);
    if(cursor.TryGotoNext(
        // This parameter determines that we want to execute our logic after the original (default is before)
        MoveType.After,
        // Now we can add a line of instructions that needs to be matched. For this we use x => x.Match{InstructionName}()
        x => x.Matchfld<HeroController>("PlayerData")
        x => x.Matchldstr("hasLantern"), // Looks for the instruction that handles a string named "hasLantern"
    ))
    {
        // Modify stuff
    }
}
```
### TODO IL Hooks
- link to IL hook page

### Todo General
-  how use custom values from player data & language (@dandy)
